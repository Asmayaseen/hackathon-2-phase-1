# sp.constitution
# Phase III Constitution - AI-Powered Todo Chatbot
# Version: 3.0
# Created: December 2025
# Project: Evolution of Todo - Panaversity Hackathon II

---

## ğŸ¯ Mission Statement

Transform the Phase II full-stack todo application into an intelligent conversational interface that allows users to manage their tasks through natural language, powered by OpenAI Agents SDK and Model Context Protocol (MCP).

**Core Principle:** "From clicks to conversations - making todo management as natural as talking to a friend."

---

## ğŸ—ï¸ Architectural Principles

### 1. Stateless Architecture

**Rule:** Server MUST NOT store conversation state in memory
**Why:** Scalability, resilience, horizontal scaling capability
**Implementation:** Every request loads full context from database
**Exception:** None - this is non-negotiable

```python
# âœ… CORRECT - Stateless
@app.post("/api/{user_id}/chat")
async def chat(user_id: str, request: ChatRequest):
    # Load history from DB every time
    history = load_conversation_history(request.conversation_id)
    # Process with fresh context
    response = await agent.run(history + [request.message])
    # Save to DB
    save_messages(conversation_id, user_message, assistant_response)
    return response

# âŒ WRONG - Stateful
conversation_cache = {}  # DON'T DO THIS!
```

### 2. MCP-First Tool Design

**Rule:** All task operations MUST go through MCP tools
**Why:** Standardized interface, AI-friendly, testable
**Implementation:** 5 core MCP tools (add, list, complete, delete, update)
**Exception:** Health checks and auth endpoints

```python
# âœ… CORRECT - MCP Tool
@mcp.tool()
async def add_task(user_id: str, title: str, description: str = None):
    """AI agent calls this to create tasks"""
    return await task_service.create_task(user_id, title, description)

# âŒ WRONG - Direct database access from agent
async def handle_add_task(user_id, title):
    db.execute("INSERT INTO tasks...")  # DON'T DO THIS!
```

### 3. Evolutionary Not Revolutionary

**Rule:** Phase II code MUST remain functional
**Why:** Users should have choice of UI vs Chat
**Implementation:** Add, don't replace
**Exception:** Bug fixes in Phase II code

```
Phase II (Keep)              Phase III (Add)
---------------              ----------------
/dashboard â†’ Task List       /chat â†’ Chatbot
/api/tasks â†’ REST API        /api/chat â†’ Chat Endpoint
                            /mcp_server/ â†’ Tools
```

### 4. Service Layer Pattern

**Rule:** Business logic MUST be in service layer
**Why:** Reusability across REST API and MCP tools
**Implementation:** Create backend/services/task_service.py
**Exception:** Simple utility functions

```python
# âœ… CORRECT - Service Layer
# backend/services/task_service.py
async def create_task(user_id: str, title: str, description: str = None):
    """Shared business logic"""
    # Validation, database operations, etc.
    pass

# backend/routes/tasks.py (REST API)
from services.task_service import create_task

# backend/mcp_server/tools.py (MCP Tools)
from services.task_service import create_task  # REUSE!
```

---

## ğŸ” Security Principles

### 1. Zero Trust - User Isolation

**Rule:** Every operation MUST verify user_id
**Implementation:** JWT token verification + user_id validation
**Exception:** None

```python
# âœ… CORRECT - User verification
@app.post("/api/{user_id}/chat")
async def chat(user_id: str, token: str = Depends(verify_jwt)):
    if token.user_id != user_id:
        raise HTTPException(403, "Unauthorized")
    # Process request
```

### 2. MCP Tool Authorization

**Rule:** All MCP tools MUST validate user_id parameter
**Why:** AI could be manipulated to access other users' data
**Implementation:** Each tool checks user ownership

```python
# âœ… CORRECT - MCP tool with validation
@mcp.tool()
async def delete_task(user_id: str, task_id: int):
    task = await db.get_task(task_id)
    if task.user_id != user_id:
        return {"error": "Task not found"}  # Don't reveal existence
    await db.delete(task)
```

### 3. Secure API Keys

**Rule:** OpenAI API key MUST be in backend only
**Why:** Frontend exposure = billing theft
**Implementation:** Environment variables, never in git

```env
# backend/.env
OPENAI_API_KEY=sk-proj-...  # Server-side only

# frontend/.env.local
NEXT_PUBLIC_OPENAI_DOMAIN_KEY=...  # ChatKit domain key only
```

---

## ğŸ¤– AI Agent Principles

### 1. Natural Language Understanding

**Rule:** Support multiple phrasings for same intent
**Implementation:** Agent should understand variations

```
Intent: Add Task
Phrases:
  - "Add buy milk"
  - "Create a task for buying milk"
  - "Remember to buy milk"
  - "I need to buy milk"
  - "Put 'buy milk' on my list"
```

### 2. Explicit Confirmations

**Rule:** Agent MUST confirm actions explicitly
**Why:** Build user trust, prevent misunderstandings
**Implementation:** Every tool call gets confirmation response

```python
# âœ… CORRECT - Explicit confirmation
response = "I've added 'Buy groceries' to your todo list!"

# âŒ WRONG - Vague response
response = "Done."
```

### 3. Graceful Error Handling

**Rule:** Never expose technical errors to user
**Implementation:** Friendly error messages

```python
# âœ… CORRECT
if task_not_found:
    return "I couldn't find that task. Would you like to see all your tasks?"

# âŒ WRONG
if task_not_found:
    raise Exception("Task ID 123 not found in database")
```

### 4. Context Awareness

**Rule:** Include recent conversation history
**Implementation:** Last 10 messages for context
**Why:** Handle follow-up questions

```
User: "Add buy milk"
Bot: "Added! Anything else?"
User: "Make it urgent"  â† Needs context to know "it" = "buy milk"
```

---

## ğŸ’¾ Database Principles

### 1. Conversation Persistence

**Rule:** ALL messages MUST be saved to database
**Why:** User expectations, debugging, analytics
**Implementation:** Save before responding

```python
# âœ… CORRECT - Save first, respond later
await save_user_message(conversation_id, user_message)
response = await agent.run(messages)
await save_assistant_message(conversation_id, response)
return response
```

### 2. Message Ordering

**Rule:** Messages MUST have timestamp and ordering
**Implementation:** Use auto-incrementing ID + timestamp

```sql
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,  -- Auto-increment ensures order
    conversation_id INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    role VARCHAR(20),
    content TEXT
);
```

### 3. Soft Deletes for Conversations

**Rule:** Never hard-delete conversation history
**Why:** User may want to restore, debugging
**Implementation:** Add `deleted_at` column

---

## ğŸ¨ User Experience Principles

### 1. Dual Interface Philosophy

**Principle:** Users choose their preference
**Implementation:** Both UIs access same data

```
Traditional UI         Chat Interface
-------------         ---------------
Visual forms    â†’     Natural language
Explicit clicks â†’     Conversational
Structured      â†’     Flexible
```

### 2. Real-time Sync

**Rule:** Changes in one interface MUST reflect in other
**Implementation:** Shared database, no caching

```
Scenario:
1. User adds task via chat: "add buy milk"
2. User opens /dashboard
3. Result: "Buy milk" task visible immediately
```

### 3. Progressive Disclosure

**Rule:** Start simple, reveal complexity gradually
**Implementation:** Basic commands first, advanced later

```
Phase 1: Learn basics
  - "add [task]"
  - "show tasks"
  - "complete [task]"

Phase 2: Advanced
  - "add buy milk due tomorrow"
  - "show high priority tasks"
  - "reschedule meeting to 3pm"
```

---

## ğŸ“Š Data Flow Principles

### 1. Single Source of Truth

**Rule:** Database is the only source of truth
**Why:** Consistency across interfaces
**Implementation:** No client-side state for data

```
âŒ WRONG Flow:
User â†’ Frontend state â†’ Maybe sync to DB

âœ… CORRECT Flow:
User â†’ Database â†’ Frontend reads from DB
```

### 2. Request/Response Cycle

**Rule:** Each chat request is independent
**Implementation:** Load context, process, save, respond

```
1. Receive request
2. Load conversation history from DB
3. Build message array for agent
4. Call OpenAI Agents SDK
5. Agent invokes MCP tools (which access DB)
6. Save response to DB
7. Return response
8. Server forgets everything (stateless!)
```

---

## ğŸ§ª Testing Principles

### 1. Test MCP Tools Independently

**Rule:** Each tool MUST have unit tests
**Why:** Tools are building blocks
**Implementation:** Mock database, test each tool

```python
# Test: add_task
async def test_add_task():
    result = await add_task("user1", "Test task")
    assert result["status"] == "created"
    assert "task_id" in result
```

### 2. Test Chat Endpoint Integration

**Rule:** End-to-end tests for common flows
**Implementation:** Test user journey

```python
# Test: Add task via chat
async def test_chat_add_task():
    response = await client.post("/api/user1/chat", json={
        "message": "add buy milk"
    })
    assert "added" in response["response"].lower()
    # Verify task exists in database
    tasks = await db.get_tasks("user1")
    assert any("milk" in task.title.lower() for task in tasks)
```

---

## ğŸš€ Performance Principles

### 1. Minimize Database Queries

**Rule:** Load conversation history efficiently
**Implementation:** Single query with LIMIT

```python
# âœ… CORRECT - Single query
messages = await db.execute("""
    SELECT * FROM messages
    WHERE conversation_id = $1
    ORDER BY created_at DESC
    LIMIT 10
""", conversation_id)

# âŒ WRONG - N+1 queries
for message_id in message_ids:
    message = await db.get_message(message_id)  # Multiple queries!
```

### 2. Token Optimization

**Rule:** Send only necessary context to OpenAI
**Implementation:** Limit history to last 10 messages
**Why:** Cost reduction, faster responses

### 3. Async Operations

**Rule:** Use async/await for I/O operations
**Implementation:** FastAPI async routes, async DB calls

```python
# âœ… CORRECT
@app.post("/api/{user_id}/chat")
async def chat(...):
    history = await load_history()  # Non-blocking
    response = await agent.run()     # Non-blocking
    await save_response()            # Non-blocking

# âŒ WRONG
def chat(...):
    history = load_history()  # Blocking!
```

---

## ğŸ“ Code Quality Principles

### 1. Spec-Driven Development

**Rule:** Write spec BEFORE code
**Process:** Specify â†’ Plan â†’ Tasks â†’ Implement
**Exception:** Critical bugs (but document after)

### 2. Type Safety

**Rule:** Use type hints everywhere
**Implementation:** Python type hints, TypeScript

```python
# âœ… CORRECT
async def add_task(
    user_id: str,
    title: str,
    description: str | None = None
) -> dict[str, Any]:
    ...

# âŒ WRONG
async def add_task(user_id, title, description=None):
    ...
```

### 3. Error Handling

**Rule:** Handle errors gracefully
**Implementation:** Try-except with logging

```python
# âœ… CORRECT
try:
    result = await agent.run(messages)
except OpenAIError as e:
    logger.error(f"OpenAI error: {e}")
    return {"error": "I'm having trouble processing that. Please try again."}
```

---

## ğŸ”„ Integration Principles

### 1. Backward Compatibility

**Rule:** Phase II API MUST remain unchanged
**Implementation:** New endpoints, don't modify old ones

```
Phase II Endpoints (DON'T CHANGE):
  GET  /api/{user_id}/tasks
  POST /api/{user_id}/tasks
  PUT  /api/{user_id}/tasks/{id}
  ...

Phase III Endpoints (ADD NEW):
  POST /api/{user_id}/chat  â† New!
```

### 2. Shared Dependencies

**Rule:** Both phases use same dependencies
**Implementation:** Single requirements.txt/package.json

```
backend/requirements.txt:
  fastapi[standard]  # Phase II
  sqlmodel           # Phase II
  python-jose        # Phase II
  openai             # Phase III (NEW)
  mcp                # Phase III (NEW)
```

---

## ğŸ¯ Success Criteria

### Definition of Done (Phase III)

**Backend:**
- âœ… 5 MCP tools implemented and tested
- âœ… Chat endpoint returns proper responses
- âœ… Conversation history persists to database
- âœ… Stateless architecture (server restarts don't lose state)
- âœ… JWT authentication integrated

**Frontend:**
- âœ… /chat page renders ChatKit
- âœ… Natural language commands work
- âœ… Bot provides confirmations
- âœ… Navigation between /dashboard and /chat works

**Integration:**
- âœ… Tasks created via chat appear in dashboard
- âœ… Tasks created via dashboard manageable via chat
- âœ… Same authentication for both interfaces

**Quality:**
- âœ… All specs documented
- âœ… CLAUDE.md updated
- âœ… README reflects Phase III
- âœ… Demo video under 90 seconds

---

## âš ï¸ Anti-Patterns (What NOT to Do)

### 1. âŒ Duplicate Task Logic

```python
# DON'T create separate task creation logic
# backend/routes/tasks.py
def create_task_rest(...):  # One implementation
    ...

# backend/mcp_server/tools.py
def create_task_mcp(...):  # Another implementation âŒ
    ...

# DO: Share via service layer
from services.task_service import create_task  # Reuse! âœ…
```

### 2. âŒ Client-Side AI Keys

```javascript
// frontend/lib/openai.ts
const openai = new OpenAI({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_KEY  // âŒ NEVER!
});
```

### 3. âŒ In-Memory Conversation Storage

```python
# âŒ DON'T DO THIS
conversations = {}  # Lost on restart!

# âœ… DO THIS
async def get_conversation(id):
    return await db.query("SELECT * FROM conversations WHERE id = $1", id)
```

### 4. âŒ Modifying Phase II Code

```python
# backend/routes/tasks.py

# âŒ DON'T CHANGE THIS
@router.post("/api/{user_id}/tasks")
async def create_task(...):  # Keep as-is!
    ...

# âœ… ADD NEW ROUTE
@router.post("/api/{user_id}/chat")  # New endpoint
async def chat(...):
    ...
```

---

## ğŸ“š Documentation Requirements

### 1. Spec Files (Required)

- specs/features/ai-chatbot.md - Feature specification
- specs/api/chat-endpoint.md - Chat API documentation
- specs/api/mcp-tools.md - MCP tools specification
- specs/database/chat-schema.md - Database schema

### 2. Code Comments

```python
# âœ… GOOD - Explains WHY
async def load_history(conversation_id: int, limit: int = 10):
    """Load last N messages for context.

    We limit to 10 messages to:
    1. Reduce OpenAI token costs
    2. Keep context window manageable
    3. Improve response speed
    """
```

### 3. README Updates

- Add Phase III section
- Update architecture diagram
- Document new environment variables
- Add chat endpoint examples

---

## ğŸ” Environment Variable Standards

### Naming Convention

```env
# Backend (backend/.env)
DATABASE_URL=...           # Existing
BETTER_AUTH_SECRET=...     # Existing
OPENAI_API_KEY=...         # NEW Phase III
MCP_SERVER_PORT=9000       # NEW Phase III (optional)

# Frontend (frontend/.env.local)
NEXT_PUBLIC_API_URL=...                 # Existing
NEXT_PUBLIC_OPENAI_DOMAIN_KEY=...       # NEW Phase III
BETTER_AUTH_SECRET=...                  # Existing (shared with backend)
```

### Security Rules

- âœ… Backend-only: `OPENAI_API_KEY`
- âœ… Shared secret: `BETTER_AUTH_SECRET` (same in both)
- âœ… Public: `NEXT_PUBLIC_*` variables
- âŒ Never commit: `.env` files (use `.env.example`)

---

## ğŸ¬ Deployment Principles

### 1. Staged Rollout

```
1. Deploy Phase III backend (chat endpoint)
2. Test MCP tools independently
3. Deploy Phase III frontend (/chat page)
4. Test integration
5. Phase II remains available throughout
```

### 2. Rollback Strategy

```
- Phase III fails? Phase II still works
- Remove /chat route from frontend
- Disable chat endpoint
- Users continue with dashboard
```

---

## ğŸ†˜ Troubleshooting Guidelines

**Problem:** "MCP Tool Not Found"
**Check:**
- Is MCP SDK installed? `pip list | grep mcp`
- Is tool registered? Check `mcp_server/server.py`
- Is tool name correct in agent prompt?

**Problem:** "Conversation State Lost"
**Check:**
- Are messages being saved? Check database
- Is conversation_id being passed?
- Is database query correct?

**Problem:** "ChatKit Not Loading"
**Check:**
- Is domain added to OpenAI allowlist?
- Is `NEXT_PUBLIC_OPENAI_DOMAIN_KEY` set?
- Is frontend deployed (localhost won't work in production)?

---

## ğŸ“Š Metrics & Monitoring

### Key Metrics to Track

- Chat Response Time - Target: <2 seconds
- MCP Tool Success Rate - Target: >95%
- OpenAI API Costs - Monitor token usage
- User Adoption - Chat vs Dashboard usage
- Error Rate - Target: <1%

### Logging Standards

```python
# âœ… GOOD - Structured logging
logger.info("Chat request", extra={
    "user_id": user_id,
    "conversation_id": conversation_id,
    "message_length": len(message),
    "response_time": response_time
})

# âŒ BAD - Unstructured logging
print("Chat request from", user_id)
```

---

## ğŸ¯ Phase III Completion Definition

Phase III is considered COMPLETE when:

- âœ… All Success Criteria Met (see above)
- âœ… Demo Video Recorded (<90 seconds)
- âœ… Deployed to Production (Vercel + Backend host)
- âœ… Documentation Complete (README, specs, CLAUDE.md)
- âœ… Submission Form Filled (hackathon form)
- âœ… GitHub Repository Public (clean commit history)

---

## ğŸ† Bonus Features (Optional)

If time permits, these earn extra points:

**+200 Points: Reusable Intelligence**
- Create Claude Code subagent for MCP tools
- Create skill for chat endpoint patterns

**+100 Points: Urdu Support**
- Add language parameter to chat endpoint
- Bot responds in Urdu when requested
- Example: "Ù…ÛŒØ±Û’ Ú©Ø§Ù… Ø¯Ú©Ú¾Ø§Ø¤" â†’ Shows tasks

**+200 Points: Voice Commands**
- Add voice input to ChatKit
- Speech-to-text â†’ Chat endpoint
- Text-to-speech for responses

---

## ğŸ“œ Amendment Process

This constitution can be amended when:

- Requirements change (hackathon updates)
- Technical limitations discovered
- Better patterns identified

**Process:**
1. Document proposed change
2. Discuss with Claude Code
3. Update constitution
4. Commit with clear message

---

## âœ… Constitution Acceptance

By proceeding with Phase III development, you agree to:

- Follow all architectural principles
- Enforce security rules
- Maintain backward compatibility
- Write specs before code
- Test thoroughly
- Document comprehensively

---

**Constitution Version:** 3.0
**Effective Date:** December 2025
**Next Review:** After Phase III completion

ğŸš€ **Let's Build This!**
