# Database Schema Specification

> **Phase:** II - Full-Stack Web Application
> **Component:** Database Layer
> **Technology:** Neon Serverless PostgreSQL + SQLModel ORM

---

## ğŸ“‹ Overview

This specification defines the database schema for the Evolution of Todo application Phase II, including tables, columns, relationships, indexes, and constraints.

---

## ğŸ—„ï¸ Database Technology

| Component | Technology | Purpose |
|-----------|-----------|---------|
| Database | Neon Serverless PostgreSQL | Cloud-hosted PostgreSQL |
| ORM | SQLModel | Python ORM based on Pydantic and SQLAlchemy |
| Connection | psycopg2-binary | PostgreSQL adapter for Python |
| Migrations | Alembic | Database migration tool |

---

## ğŸ“Š Database Tables

### 1. Users Table

**Managed by Better Auth** - This table is created and managed by the Better Auth library.

```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,                    -- UUID generated by Better Auth
    email TEXT UNIQUE NOT NULL,             -- User email (unique identifier)
    name TEXT,                               -- User display name
    password_hash TEXT NOT NULL,             -- Hashed password (bcrypt)
    email_verified BOOLEAN DEFAULT false,    -- Email verification status
    created_at TIMESTAMP DEFAULT NOW(),      -- Account creation time
    updated_at TIMESTAMP DEFAULT NOW()       -- Last update time
);
```

**Indexes:**
```sql
CREATE INDEX idx_users_email ON users(email);
```

**Notes:**
- Better Auth automatically creates this table
- Do NOT manually modify this table structure
- Reference `users.id` in foreign keys using TEXT type

---

### 2. Tasks Table

**Purpose:** Stores todo task items for all users.

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,                   -- Auto-incrementing task ID
    user_id TEXT NOT NULL,                   -- Foreign key to users.id
    title TEXT NOT NULL,                     -- Task title (required)
    description TEXT,                        -- Task description (optional)
    completed BOOLEAN DEFAULT false,         -- Completion status
    created_at TIMESTAMP DEFAULT NOW(),      -- Task creation time
    updated_at TIMESTAMP DEFAULT NOW(),      -- Last modification time

    -- Foreign key constraint
    CONSTRAINT fk_user
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE                    -- Delete tasks when user deleted
);
```

**Indexes:**
```sql
-- Index for user queries (most common)
CREATE INDEX idx_tasks_user_id ON tasks(user_id);

-- Index for filtering by completion status
CREATE INDEX idx_tasks_completed ON tasks(completed);

-- Composite index for user + completion queries
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed);

-- Index for ordering by creation date
CREATE INDEX idx_tasks_created_at ON tasks(created_at DESC);
```

**Constraints:**
- `title` - NOT NULL, max 200 characters
- `description` - Nullable, max 1000 characters
- `completed` - NOT NULL, defaults to false
- `user_id` - NOT NULL, must reference valid user

---

## ğŸ”— Entity Relationships

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     users       â”‚         â”‚     tasks       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (TEXT) PK    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”¤ id (SERIAL) PK  â”‚
â”‚ email           â”‚    â”‚    â”‚ user_id (FK)    â”‚
â”‚ name            â”‚    â”‚    â”‚ title           â”‚
â”‚ password_hash   â”‚    â”‚    â”‚ description     â”‚
â”‚ email_verified  â”‚    â”‚    â”‚ completed       â”‚
â”‚ created_at      â”‚    â”‚    â”‚ created_at      â”‚
â”‚ updated_at      â”‚    â””â”€â”€â”€â”€â”‚ updated_at      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      1                             *
    (One)                        (Many)
```

**Relationship:**
- One User has Many Tasks (1:N)
- Each Task belongs to exactly one User
- Cascade delete: When user deleted, all their tasks are deleted

---

## ğŸ SQLModel Definitions

### User Model (Reference Only)

```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class User(SQLModel, table=True):
    """
    User model - Managed by Better Auth.
    This is for reference only. Do not create/modify directly.
    """
    __tablename__ = "users"

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, index=True)
    name: Optional[str] = None
    password_hash: str
    email_verified: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Task Model (Full Implementation)

```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    """
    Task model - Represents a todo item.

    Attributes:
        id: Auto-incrementing primary key
        user_id: Foreign key to users table
        title: Task title (required, max 200 chars)
        description: Task description (optional, max 1000 chars)
        completed: Completion status (default: False)
        created_at: Creation timestamp
        updated_at: Last update timestamp
    """
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = Field(default=False, index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "user_id": "user_123abc",
                "title": "Buy groceries",
                "description": "Milk, eggs, bread",
                "completed": False,
                "created_at": "2025-12-09T10:00:00Z",
                "updated_at": "2025-12-09T10:00:00Z"
            }
        }
```

---

## ğŸ”’ Data Validation Rules

### Title Field
- **Required:** Yes
- **Type:** String
- **Min Length:** 1 character
- **Max Length:** 200 characters
- **Validation:** Must not be empty or whitespace only
- **Sanitization:** Trim leading/trailing whitespace

### Description Field
- **Required:** No
- **Type:** String or NULL
- **Max Length:** 1000 characters
- **Validation:** If provided, cannot be empty string
- **Sanitization:** Trim leading/trailing whitespace, convert empty strings to NULL

### Completed Field
- **Required:** Yes (has default)
- **Type:** Boolean
- **Default:** false
- **Validation:** Must be true or false only

### User ID Field
- **Required:** Yes
- **Type:** String (TEXT)
- **Validation:** Must reference existing user in `users` table
- **Security:** Verified via JWT token on every request

---

## ğŸ” Security Considerations

### User Isolation
```sql
-- CORRECT: Filter by authenticated user
SELECT * FROM tasks WHERE user_id = <authenticated_user_id>;

-- INCORRECT: Never allow unfiltered queries
SELECT * FROM tasks;  -- âŒ SECURITY VIOLATION
```

### SQL Injection Prevention
- **Use SQLModel/SQLAlchemy ORM** - Automatic parameterization
- **Never concatenate SQL strings** - Always use parameters
- **Validate all inputs** - Use Pydantic schemas

```python
# CORRECT: Parameterized query (SQLModel handles this)
task = session.query(Task).filter(Task.id == task_id, Task.user_id == user_id).first()

# INCORRECT: String concatenation
query = f"SELECT * FROM tasks WHERE id = {task_id}"  # âŒ SQL INJECTION RISK
```

### Authorization Checks
Every database query MUST include user_id filter:

```python
# CORRECT: User-scoped query
def get_user_tasks(db: Session, user_id: str) -> list[Task]:
    return db.query(Task).filter(Task.user_id == user_id).all()

# INCORRECT: Global query
def get_all_tasks(db: Session) -> list[Task]:
    return db.query(Task).all()  # âŒ SECURITY VIOLATION
```

---

## ğŸ› ï¸ Database Operations

### Create Operations

```python
from sqlmodel import Session

def create_task(db: Session, user_id: str, title: str, description: str | None = None) -> Task:
    """Create a new task for the authenticated user."""
    task = Task(
        user_id=user_id,
        title=title.strip(),
        description=description.strip() if description else None
    )
    db.add(task)
    db.commit()
    db.refresh(task)
    return task
```

### Read Operations

```python
def get_user_tasks(
    db: Session,
    user_id: str,
    status: str = "all",
    sort_by: str = "created"
) -> list[Task]:
    """Retrieve tasks for authenticated user with optional filters."""
    query = db.query(Task).filter(Task.user_id == user_id)

    # Filter by status
    if status == "completed":
        query = query.filter(Task.completed == True)
    elif status == "pending":
        query = query.filter(Task.completed == False)

    # Sort results
    if sort_by == "title":
        query = query.order_by(Task.title)
    elif sort_by == "updated":
        query = query.order_by(Task.updated_at.desc())
    else:  # default: created
        query = query.order_by(Task.created_at.desc())

    return query.all()

def get_task_by_id(db: Session, user_id: str, task_id: int) -> Task | None:
    """Retrieve a specific task, ensuring user ownership."""
    return db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == user_id  # SECURITY: User isolation
    ).first()
```

### Update Operations

```python
def update_task(
    db: Session,
    user_id: str,
    task_id: int,
    title: str | None = None,
    description: str | None = None
) -> Task | None:
    """Update task fields, ensuring user ownership."""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == user_id  # SECURITY: User isolation
    ).first()

    if not task:
        return None

    if title is not None:
        task.title = title.strip()
    if description is not None:
        task.description = description.strip() if description else None

    task.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(task)
    return task

def toggle_task_completion(db: Session, user_id: str, task_id: int) -> Task | None:
    """Toggle task completion status."""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == user_id  # SECURITY: User isolation
    ).first()

    if not task:
        return None

    task.completed = not task.completed
    task.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(task)
    return task
```

### Delete Operations

```python
def delete_task(db: Session, user_id: str, task_id: int) -> bool:
    """Delete a task, ensuring user ownership."""
    task = db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == user_id  # SECURITY: User isolation
    ).first()

    if not task:
        return False

    db.delete(task)
    db.commit()
    return True
```

---

## ğŸ“Š Database Statistics Queries

```python
def get_task_statistics(db: Session, user_id: str) -> dict:
    """Get task counts for authenticated user."""
    total = db.query(Task).filter(Task.user_id == user_id).count()
    completed = db.query(Task).filter(
        Task.user_id == user_id,
        Task.completed == True
    ).count()
    pending = total - completed

    return {
        "total": total,
        "completed": completed,
        "pending": pending
    }
```

---

## ğŸ”„ Database Migrations

### Initial Migration (Create Tables)

```python
# alembic/versions/001_create_tasks_table.py

from alembic import op
import sqlalchemy as sa

def upgrade():
    # Tasks table (users table created by Better Auth)
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.Text(), nullable=False),
        sa.Column('title', sa.Text(), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('completed', sa.Boolean(), nullable=False, server_default='false'),
        sa.Column('created_at', sa.TIMESTAMP(), nullable=False, server_default=sa.text('now()')),
        sa.Column('updated_at', sa.TIMESTAMP(), nullable=False, server_default=sa.text('now()')),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE')
    )

    # Create indexes
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_completed', 'tasks', ['completed'])
    op.create_index('idx_tasks_user_completed', 'tasks', ['user_id', 'completed'])
    op.create_index('idx_tasks_created_at', 'tasks', ['created_at'], postgresql_ops={'created_at': 'DESC'})

def downgrade():
    op.drop_index('idx_tasks_created_at', table_name='tasks')
    op.drop_index('idx_tasks_user_completed', table_name='tasks')
    op.drop_index('idx_tasks_completed', table_name='tasks')
    op.drop_index('idx_tasks_user_id', table_name='tasks')
    op.drop_table('tasks')
```

---

## ğŸ” Query Performance

### Indexed Queries (Fast)

âœ… `WHERE user_id = ?` - Uses `idx_tasks_user_id`
âœ… `WHERE user_id = ? AND completed = ?` - Uses `idx_tasks_user_completed`
âœ… `ORDER BY created_at DESC` - Uses `idx_tasks_created_at`

### Non-Indexed Queries (Slow)

âŒ `WHERE title LIKE '%search%'` - Full table scan (Phase III: Add full-text search)
âŒ `WHERE description LIKE '%keyword%'` - Full table scan

---

## ğŸ“ˆ Scalability Considerations

### Current Design (Phase II)
- **Expected Load:** 100-1,000 users
- **Tasks per User:** 1-100 tasks
- **Total Tasks:** ~100,000 tasks
- **Query Performance:** <50ms with indexes

### Future Optimizations (Phase III+)
- Full-text search index for title/description
- Materialized views for statistics
- Partitioning by user_id (>1M tasks)
- Read replicas for scaling reads

---

## ğŸ§ª Testing Recommendations

### Unit Tests
```python
def test_create_task():
    task = Task(user_id="user123", title="Test task")
    assert task.title == "Test task"
    assert task.completed == False
    assert task.user_id == "user123"

def test_task_validation():
    with pytest.raises(ValidationError):
        Task(user_id="user123", title="")  # Empty title should fail
```

### Integration Tests
```python
def test_user_isolation(db: Session):
    # User 1 creates task
    task1 = create_task(db, "user1", "User 1 task")

    # User 2 should NOT see User 1's task
    task = get_task_by_id(db, "user2", task1.id)
    assert task is None  # SECURITY: User isolation verified
```

---

## ğŸ“‹ Acceptance Criteria

**Schema Implementation:**
- [ ] `users` table exists (created by Better Auth)
- [ ] `tasks` table created with all columns
- [ ] Foreign key constraint `tasks.user_id â†’ users.id` exists
- [ ] All indexes created
- [ ] Cascade delete configured

**Security:**
- [ ] All queries filter by `user_id`
- [ ] SQL injection prevention via SQLModel ORM
- [ ] Input validation via Pydantic
- [ ] Authorization checks in all operations

**Performance:**
- [ ] Queries with indexes run <50ms
- [ ] User task lists load <100ms
- [ ] Statistics queries run <20ms

---

## ğŸ”— Related Specifications

- **API Specification:** `specs/api/rest-endpoints.md`
- **Feature Specification:** `specs/features/task-crud.md`
- **Authentication Spec:** `specs/features/authentication.md`

---

**Database Schema Version:** 1.0
**Last Updated:** Phase II - December 9, 2025
**Status:** âœ… Ready for Implementation
